var width = 500,    height = 200,    circleRadius = Math.min(width, height) / 3.5,    padding = 40,    circleThickness = 30,    tweenDuration = 1250;var arcs = [];var pie = d3.layout.pie().value(function(d) {return d.prediction; }).sort(null);var aspects = ["leftright","domain","manifestocode"]var colors = {		"leftright":d3.scale.category20(),//function (i){c = [ "#100000","#FF0000"];return c[i]}		"domain":d3.scale.category20(),		"manifestocode":d3.scale.category20()		};var url = "url"var text = "text"var svg = d3.select("#result").append("svg").attr("width", width).attr("height", height)var key = function(d){ return d.label; };function tipString(p){ return p.label+": "+ Math.round(p.prediction*100.0)/100; }function midAngle(d){ return d.startAngle + (d.endAngle - d.startAngle)/2; }setup();function setup(){	d3.json("/api/predict")		.header("Content-type", "application/x-www-form-urlencoded")		.post("text=  ", function(error, prediction) {		for (a in aspects) {			arcs[a] = d3.svg.arc()					.innerRadius(circleRadius - circleThickness)					.outerRadius(circleRadius)			svg.append("g").attr("class",aspects[a])				.attr("transform", "translate(" + (a * ((width/4.0)+padding) + (circleRadius)) + "," + height / 2 + ")")			svg.selectAll("g."+aspects[a]).selectAll("path")				.data(pie(prediction[aspects[a]]))			  .enter()			   .append("path").attr("class", function(d) {return d.label})			.attr("fill", function(d, i) {return colors[aspects[a]](i); })				.attr("d", arcs[a])				 .each(function(d) {this._current = d; })				 .append("svg:title")						   .text(function(d,i){return tipString(prediction[aspects[a]][i]);})		}	})}function visualize(queryTextElement, dataType){	var queryText = queryTextElement.value	d3.json("/api/predict")		.header("Content-type", "application/x-www-form-urlencoded")		.post(dataType + "=" + queryText, function(error, prediction) {		for (a in aspects) {			arc = arcs[a]			paths = svg				.selectAll("g."+aspects[a])				.selectAll("path")				.data(pie(prediction[aspects[a]]));			paths.enter()				.append("path")				.attr("class", function(d) {return d.label})				.attr("fill", function(d, i) {return colors[aspects[a]](i); })				.attr("d", arc)				 .select("title")				 .text(function(d,i){return tipString(prediction[aspects[a]][i]);})			paths.transition()				.duration(tweenDuration)				.attrTween("d", arcTween).select("title")				 .text(function(d,i){return tipString(prediction[aspects[a]][i]);});			paths.exit()			  .remove();			// get maximum prediction			var maxPred = {label:"",prediction:0.0}			for (key in prediction[aspects[a]]){			if (maxPred.prediction < prediction[aspects[a]][key].prediction) {			maxPred.label = prediction[aspects[a]][key].label;			maxPred.prediction = prediction[aspects[a]][key].prediction;}			}			// show maximum prediction below pie chart			svg.select("g."+aspects[a]).selectAll("text").remove()			svg.select("g."+aspects[a])				.append("text")				.text(maxPred.label)				.style("text-anchor","middle")				.attr("transform", "translate(0," + (circleRadius + 30) + ")");			// show prediction in center of pie chart			svg.select("g."+aspects[a])				.append("text")				.text(Math.round(maxPred.prediction*100.0)/100)				.style("text-anchor","middle")				.attr("transform", "translate(0,5)")			// show type of classifier on top of pie chart			svg.select("g."+aspects[a])				.append("text")				.text(aspects[a])				.style("text-anchor","middle")				.attr("transform", "translate(0," +  -( circleRadius + circleThickness - 10 ) + ")")		}	})}// Store the currently-displayed angles in this._current.// Then, interpolate from this._current to the new angles.function arcTween(a) {  var i = d3.interpolate(this._current, a);  this._current = i(0);  return function(t) {    return arc(i(t));  };}